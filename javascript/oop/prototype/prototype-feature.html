<html> 
	<head> 
  		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  		<title>prototype-feature</title> 
		<script>
			var f1 = {echo: function() { alert("sound"); } };
			function Foo() {};
			var foo = new Foo(); // foo的基引用指向Object实例
			Foo.prototype = f1;
			
			Foo.prototype.echo=function(){alert("video")};
			/* 如果先实例化出一个对象, 再为构造函数prototype赋予一个不同的对象, 将会: 已经创建的对象的基引用不变, 将来创建的对象的基引用为新的原型对象: */
			alert(foo.echo);
			
			var foo2 = new Foo(); // foo2的基引用指f1对象
			foo2.echo(); // output: video
			
			//由于引用对象的特性，会修改被引用的对象
			f1.echo(); // output: sound
			
			//所有的构造函数的prototype都不能为空, 就是说Superman.prototype = null 会被引擎无视;  
			//另一方面, Object构造函数也有prototype属性(该属性是只读的, 可以为原型增加属性,但不能赋予不同的对象), 
			Object.prototype.test = function() {
				alert("test");
			}
			
			
			// echo属性将增加到所有对象固有对象和自定义对象
			var arr = new Array();
			arr.test();
			Array.test();
			
			//故因此可以有多层的原型链, 但原型链的根必定会是Object.prototype,这意味着给Object.prototype增加属性影响到所有对象
			function ObjCons()    {
			    this.dummy = "d";
			}
			var obj = new ObjCons();
			obj.test();
			ObjCons.test();
		</script>
	</head>
</html>